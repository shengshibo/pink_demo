<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			
		</style>
	</head>
	<body>
		<ul id="u1">
			<li><a href="javascript:;" class="link">超链接一</a></li>
			<li><a href="javascript:;" class="link">超链接二</a></li>
			<li><a href="javascript:;" class="link">超链接三</a></li>
		</ul>
		<input type="submit" value="新增" id="btn01" />
		<script type="text/javascript">
			window.onload = function () {
				var u1 = document.getElementById("u1");
				var btn01 = document.getElementById("btn01");
				btn01.onclick = function () {
					var li = document.createElement("li");
					li.innerHTML = "<a href='javascript:;' class='link'>新超链接</a>";
					u1.appendChild(li);
				}
				
				/*
					为每一个超链接都绑定一个单击响应函数
					这里我们为每一个超链接都绑定了一个单击响应函数，这种操作比较麻烦，
					而且这种操作只能为已有的超链接设置事件，而新添加的超链接必须重新绑定
				*/
				// 获取所有的 a
				var allA = document.getElementsByTagName("a");
				// 遍历
				// for (var i = 0; i < allA.length; i++) {
				// 	allA[i].onclick = function () {
				// 		alert("我是 a 的单击响应函数");
				// 	}
				// }
				/*
					我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后添加的
					我们可以尝试将其绑定给元素共同的祖先元素
					
					事件的委派
						- 指将事件统一绑定给元素共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素
						- 事件委派是利用的冒泡，通过委派可以减少事件绑定的次数，提高程序的性能
				*/
				// 为 ul 绑定一个单击响应函数
				u1.onclick = function (event) {
					// alert("我是 ul 的单击响应函数");
					event = event || window.event;
					/*
						target
							event 中的 target 表示触发事件的对象
					*/
					if (event.target.className == "link") {
						alert("执行了");
					}
					console.log(event.target);
				}
			}
		</script>
	</body>
</html>
